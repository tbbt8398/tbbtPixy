#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTPB,           sensorI2CCustom9V)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorH,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

static int Xpoint;
static int Ypoint;
int middle;

task comm;

bool getXY()
{
	int const replySize = 1;
	char send[3] = {2, 0x10, 128};
	char send2[3] = {2, 0x10, 136};
	char packet[1];
	for (int i = 0; i < 2; i++)
	{
		if (i == 0)
		{
			sendI2CMsg(HTPB, send, replySize);
			sleep(200);
			readI2CReply(HTPB, packet, replySize);
			Xpoint = packet;
		}
		else
		{
			sendI2CMsg(HTPB, send2, replySize);
			sleep(200);
			readI2CReply(HTPB, packet, replySize);
			if(Ypoint != packet)
			{
				Ypoint = packet;
				return true;
			}
		}
	}
	return false;
}

void turnForPixy(bool state)
{
	int motorspd = 126;
	int j = 0;

	if(state)
	{
		char packet[] = {2, 0x10, 0x52, 0x00, 0x00, 0x00, 0xFF, 0x02};
		hogCPU();
		while(i2cStatusPending == nI2CStatus[HTPB]);
		sendI2CMsg(HTPB, packet, 0);
		sleep(100);
		releaseCPU();
	}
	else
	{
		char packet[] = {2, 0x10, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00};
		hogCPU();
		while(i2cStatusPending == nI2CStatus[HTPB]);
		sendI2CMsg(HTPB, packet, 0);
		sleep(100);
		releaseCPU();
	}

	while(j <= 3)
	{
		eraseDisplay();
		displayTextLine(1, "%d", Xpoint);
		drawCircle(Xpoint/2.65625 - 2, Ypoint/7.0833 + 2, 4);
		motorspd = .4 * (Xpoint - middle);
		motor[motorD] = motorspd;
		motor[motorE] = motorspd;
		motor[motorF] = -motorspd;
		motor[motorG] = -motorspd;
		sleep(300);
		motor[motorD] = 0;
		motor[motorE] = 0;
		motor[motorF] = 0;
		motor[motorG] = 0;
		sleep(100);
		if(abs(motorspd) < 5)
		{
			j++;
		}
		else
		{
			j = 0;
		}
	}
}

void move(int Lspeed, int Rspeed, int time)
{
	motor[motorD] = Lspeed;
	motor[motorE] = Lspeed;
	motor[motorF] = Rspeed;
	motor[motorG] = Rspeed;
	sleep(time);
	motor[motorD] = 0;
	motor[motorE] = 0;
	motor[motorF] = 0;
	motor[motorG] = 0;
}

void callibrate()
{
	while(nNxtButtonPressed != 2)
	{
	eraseDisplay();
	displayTextLine(1, "x = %d", Xpoint);
	displayTextLine(3, "y = %d", Ypoint);
	drawCircle(Xpoint/2.65625 - 2, Ypoint/7.0833 + 2, 4);
}
  middle = Xpoint;
}

task main()
{
	startTask(comm);
	callibrate();
	turnForPixy(0);
	move(20, 20, Ypoint * 30);
	sleep(500);
	/*motor[motorH] = -100;
	sleep(1500);
	motor[motorH] = 0;
	motor[motorI] = -50;
	sleep(1000);
	motor[motorH] = 100;
	sleep(1000);
	turnForPixy(false);
	*/
	stopAllTasks();
}

task comm()
{
	int error = 0;
	while(true)
	{
		wait1Msec(500);
		if(!getXY())
		{
			error++;
			if(error == 500)
			{
				error = 0;
				Xpoint = 126;
			}
		}
		else
		{
			error = 0;
		}
	}
}


///////////////////mem map////////////////////////////
//SharedMem01 = 128
//SharedMem02 = 132
//SharedMem03 = 136
//SharedMem04 = 140
//SharedMem32 = 252
//each mem is 32 bit
//
//
